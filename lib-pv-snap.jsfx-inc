@init

N_INITIAL_PARAMETERS = 100;
curSelected; 

function pvSnapSize() (
	N_INITIAL_PARAMETERS+4*HALF_FFTSIZE;
);

function pvSnapSerializedSize() (
	N_INITIAL_PARAMETERS+2*HALF_FFTSIZE;
);

function snapMPtr(point) (
	point+N_INITIAL_PARAMETERS;
);

function snapFPtr(point) (
	point+N_INITIAL_PARAMETERS+HALF_FFTSIZE;
);

function compMPtr(point) (
	point+N_INITIAL_PARAMETERS+2*HALF_FFTSIZE;
);

function compFPtr(point) (
	point+N_INITIAL_PARAMETERS+3*HALF_FFTSIZE;
);


POLARITY_FLAG=1;
IS_INPUT_FLAG=2;
IS_MUTE_FLAG=4;
IS_NORMALIZED_FLAG=8;

SNAP_X = 4;
SNAP_Y = 5;
SNAP_GAIN = 7;
SNAP_PAN = 8;
SNAP_FLAGS = 9;
SNAP_TRANSP = 10;
SNAP_LO_CUT = 11;
SNAP_HI_CUT = 12;
SNAP_BOTTOM_CUT = 13;
SNAP_MOVEMENT_V = 14;
SNAP_MOVEMENT_R = 15;
SNAP_P_SHIFT = 16;

SNAP_LFO_PH	= 17;

SNAP_LEFT_WEIGHT = 30;
SNAP_RIGHT_WEIGHT = 31;

ASCII_A = 65;

function setDataChanged() (
	lastDataChange==0 ?	lastDataChange = time_precise();
);

function initPVSnap(ptr)  (
	a00_initPVSnap +=1;
	
	ptr[SNAP_X] = 0;
	ptr[SNAP_Y] = 0;
	ptr[SNAP_LEFT_WEIGHT] = 0;
	ptr[SNAP_RIGHT_WEIGHT] = 0;
	ptr[SNAP_GAIN] = 0;
	ptr[SNAP_FLAGS] = 0; // flags
	ptr[SNAP_TRANSP] = 0;
	ptr[SNAP_LO_CUT] = 0;
	ptr[SNAP_HI_CUT] = 1;
	ptr[SNAP_LFO_PH] = 0;
	ptr[SNAP_MOVEMENT_R] = 0;
	ptr[SNAP_MOVEMENT_V] = 0;
	ptr[SNAP_BOTTOM_CUT] = 0;
	setDataChanged();
	ptr;
);


function initPVSnapLib() local(i) (


	globalTranspose = 1;

	points = local_memalloc(MAX_N_POINTS);
	i=0;
	loop(MAX_N_POINTS,
		points[i] = local_memalloc(pvSnapSize());
		i+=1;
	);
	npoints = 0;
);

function pointLabel(i) local(flags lab point) (
	lab = STR_POINT_LABEL;
	point = points[i];
	i<0 ? sprintf(lab, "?") : (
		flags = point[SNAP_FLAGS] & (IS_ZERO_FLAG | IS_INPUT_FLAG  | POLARITY_FLAG  );
		flags & IS_ZERO_FLAG ? (
			sprintf(lab, "0 %c" , ASCII_A+i);
		) : (
			flags & IS_INPUT_FLAG ? (
				flags & POLARITY_FLAG 
					? sprintf(lab, "-in %c" , ASCII_A+i) 
					: sprintf(lab, "in %c" , ASCII_A+i);
			):(
				flags & POLARITY_FLAG 
					? sprintf(lab, "-%c" , ASCII_A+i) 
					: sprintf(lab, "%c" , ASCII_A+i);
			)
		);
	);
	lab;
);


// function OLD_setInputData(destSnap) local(t, srcSnap) (
// 	t = (nextSnapIn-1-getSnapRotate+SNAP_QUEUE_LENGTH) % SNAP_QUEUE_LENGTH;
// 	t = clip(t, 0, SNAP_QUEUE_LENGTH-1);
// 	srcSnap = snapQueue[t];
// 	memcpy(snapMPtr(destSnap), snapMPtr(srcSnap), HALF_FFTSIZE);
// 	memcpy(snapFPtr(destSnap), snapFPtr(srcSnap), HALF_FFTSIZE);
// 	setDataChanged();
// );


function setInputData(index m f) local(point) (
	point = points[index];
	memcpy(snapMPtr(point), snapMPtr(m), HALF_FFTSIZE);
	memcpy(snapFPtr(point), snapFPtr(f), HALF_FFTSIZE);
	setDataChanged();
);



function fixedComputePoint(index) local (point bmin bmax band freq nfreq transp srcm srcf trgm trgf i g m ps loCut hiCut bottomCut) (
	point = points[index];
	srcm = snapMPtr(point);
	srcf = snapFPtr(point);	
	trgm = compMPtr(point);
	trgf = compFPtr(point);

	loCut = pow(point[SNAP_LO_CUT], 3)*(srate/2);
	hiCut = pow(point[SNAP_HI_CUT], 3)*(srate/2);
	bottomCut = pow(point[SNAP_BOTTOM_CUT], 6);

	g = fromDb(discretize(point[SNAP_GAIN]*48));

	bmin = -OVERLAPS/2+1;
	bmax = OVERLAPS/2-1;
	memset(trgm, 0, HALF_FFTSIZE);
	memset(trgf, 0, HALF_FFTSIZE);
	i=1;

	transp = point[SNAP_TRANSP];
	transp = pow(2, transp/12);

	ps = point[SNAP_P_SHIFT];
	ps = ps>=0 ? pow(ps, 5)*1000 : -pow(-ps, 5)*1000;
	a00_ps=ps;
	loop(HALF_FFTSIZE-1,
		freq = (srcf[i]+ps)*transp;
		m = srcm[i]*g;

		freq>=loCut && freq<=hiCut && srcm[i]>bottomCut ? (
			m = srcm[i]*g;
			nfreq = freq * FFTSIZE/srate;
			trgm[i] = m;
			trgf[i] = freq;
		);
		i+=1;
	);
);

function realComputePoint(index) local (point bmin bmax band freq nfreq transp srcm srcf trgm trgf i g m ps loCut hiCut bottomCut) (
	point = points[index];
	srcm = snapMPtr(point);
	srcf = snapFPtr(point);	
	trgm = compMPtr(point);
	trgf = compFPtr(point);

	loCut = pow(point[SNAP_LO_CUT], 3)*(srate/2);
	hiCut = pow(point[SNAP_HI_CUT], 3)*(srate/2);
	bottomCut = pow(point[SNAP_BOTTOM_CUT], 6);

	g = fromDb(discretize(point[SNAP_GAIN]*48));

	bmin = -OVERLAPS/2+1;
	bmax = OVERLAPS/2-1;
	memset(trgm, 0, HALF_FFTSIZE);
	memset(trgf, 0, HALF_FFTSIZE);
	i=1;

	transp = point[SNAP_TRANSP];
	transp = pow(2, transp/12);

	ps = point[SNAP_P_SHIFT];
	ps = ps>=0 ? pow(ps, 5)*1000 : -pow(-ps, 5)*1000;
	a00_ps=ps;
	loop(HALF_FFTSIZE-1,
		freq = (srcf[i]+ps)*transp;
		m = srcm[i]*g;

		freq>=loCut && freq<=hiCut && srcm[i]>bottomCut ? (
			m = srcm[i]*g;
			nfreq = freq * FFTSIZE/srate;
			allocated = 0;

			//try to allocate in the "right" band, if it is free
			band = floor(nfreq+.5);
			(band>=1) && (band <HALF_FFTSIZE) && trgm[band]== 0 ? (
				allocated = 1;
				trgm[band] = m;
				trgf[band] = freq;
			);

			//try to allocate in a free band in the range b+bmin,b+bmax
			b = bmin;
			loop(bmax-bmin+1,

				band = floor(nfreq+.5) + b;
				//band=i;
				(band>=1) && (band <HALF_FFTSIZE) && (allocated==0) && (trgm[band]==0) ? (
					allocated = 1;
					trgm[band] = m;
					trgf[band] = freq;
				);
				b += 1
			);

			allocated==0? ( // no free band found, look for a band with low magnitude
				b = bmin;
				loop(bmax-bmin+1,
					band = floor(nfreq+.5) +b;
					(band>=1) && (band <HALF_FFTSIZE)  && (allocated==0) && (trgm[band]<m) ? (
							// my magn is higher than this, i take the band
						allocated = 1;
						trgm[band] = m;
						trgf[band] = freq;
					);
					b+=1
				);
			);
			// allocated==0 ? (
			// 	// not found a good band to place our freq
			// 	// we do nothing
			// );
		);
		i+=1;
	);
);

function computePoint(index)  (
	points[index][SNAP_FLAGS] & IS_NORMALIZED_FLAG
		? realComputePoint(index)
		: fixedComputePoint(index);
);

function captureSnap() local(ptr) (

	curHoveredPoint<0 ?(
		ptr = initPVSnap(POINT_MEMORY+npoints*pvSnapSize());

		points[npoints] = ptr;
		curSelected = npoints;
		npoints +=1;
		ptr[SNAP_X] = mouse_norm_x;
		ptr[SNAP_Y] = mouse_norm_y;
		sprintf(STR_POINT_NAMES+curSelected, "spectre %c", 'A' + curSelected);
	) : (
		ptr = points[curSelected];
	);

	//setInputData(ptr);
	memset(snapMPtr(snap), 0, HALF_FFTSIZE);
	ptr[SNAP_LEFT_WEIGHT] = ptr[SNAP_RIGHT_WEIGHT] = 1;	// weight
	computePoint(curSelected);
	setDataChanged();
);


function getPointX(p) (
	p[SNAP_X] + sin(p[SNAP_LFO_PH])*pow(p[SNAP_MOVEMENT_R],4);
);


function getPointY(p) (
	p[SNAP_Y] + cos(p[SNAP_LFO_PH])*pow(p[SNAP_MOVEMENT_R],4);
);


function computeWeigths() local(i wLeft wRight d dx dy px py pxLeft pyLeft pxRight pyRight point)(
	i=0;

	pxLeft = xPlayLeft;
	pxRight = xPlayRight;
	pyLeft = yPlayLeft;
	pyRight = yPlayRight;
	totalWeightLeft = totalWeightRight = 0;

	loop(npoints,
		point = points[i];
		enabled = (point[SNAP_FLAGS] & IS_MUTE_FLAG) == 0;
		enabled = enabled && (soloPoint<0 || soloPoint==i);
		px = getPointX(point);
		py = getPointY(point);
		
		dx = px-pxLeft;
		dy = py-pyLeft;
		d = sqrt(dx*dx+dy*dy);
		enabled 
			? wLeft = ((d==0) ? 9999 : pow(1/d, walpha))
			: wLeft = 0;
		points[i][SNAP_LEFT_WEIGHT] = wLeft;
		totalWeightLeft += wLeft;

		dx = px-pxRight;
		dy = py-pyRight;
		d = sqrt(dx*dx+dy*dy);
		enabled 
			? wRight = ((d==0) ? 9999 : pow(1/d, walpha))
			: wRight = 0;
		points[i][SNAP_RIGHT_WEIGHT] = wRight;
		totalWeightRight += wRight;
		
		i += 1;
	);
	setDataChanged();
);


function setEnhPivot() local(i enhPivotBase) (
	enhPivotBase = fromDb(enhCenter);
	i=0;
	loop(HALF_FFTSIZE,
		//enhPivot[i] = enhPivotBase; 
		enhPivot[i] = enhPivotBase*pow(i, -enhCenterBend); 
		i+=1;
	);
);


function interpolateSnaps() local(i j m wLeft wRight mag g 
	gainLeft gainRight pan polarity m ma transp mw g m point isInput m f a ga gb gc
	y vfa vfb pivot) ( 

	// initial clear
	memset(ml, 0, HALF_FFTSIZE); // magnitude left
	memset(fl, 0, HALF_FFTSIZE); // freq left
	memset(mr, 0, HALF_FFTSIZE); // magnitude right
	memset(fr, 0, HALF_FFTSIZE); // freq right

	memset(wbandm_l, 0, HALF_FFTSIZE);
	memset(wbandf_l, 0, HALF_FFTSIZE);
	memset(wbandm_r, 0, HALF_FFTSIZE);
	memset(wbandf_r, 0, HALF_FFTSIZE);

	computeWeigths();
	
	m  = FFTSIZE/srate;

	j = 0; loop (npoints,

		point = points[j];
		wLeft = point[SNAP_LEFT_WEIGHT];
		wRight = point[SNAP_RIGHT_WEIGHT];

		// transpose,gain, pan, filter, polarity
		isInput = point[SNAP_FLAGS] & IS_INPUT_FLAG;

		m = isInput ? snapMPtr(lastInputSnap) : compMPtr(point);
		f = isInput ? snapFPtr(lastInputSnap) : compFPtr(point);

		// transp = point[SNAP_TRANSP];
		// transp = pow(2, transp/12);

		// g = fromDb(discretize(point[SNAP_GAIN]*48));
		pan = point[SNAP_PAN];
		gainLeft = pow(clip(pan+1, 0, 1),3);
		gainRight = pow(clip(1-pan, 0, 1),3);

		// loCut = pow(point[SNAP_LO_CUT], 3)*(HALF_FFTSIZE-1);
		// hiCut = pow(point[SNAP_HI_CUT], 3)*(HALF_FFTSIZE-1);
		// bottomCut = pow(point[SNAP_BOTTOM_CUT], 6);

		polarity = (point[SNAP_FLAGS] & POLARITY_FLAG) ? -1 : 1;

		i=0; 
		loop(HALF_FFTSIZE,
			freq = f[i]*globalTranspose;
			band = floor(i*globalTranspose+.5);

			band>=0 && band<HALF_FFTSIZE ? (
				mag = m[i];
				mag = mag * wLeft * gainLeft;
				ml[band] += mag * polarity;
				wbandm_l[band] += wLeft; 
				fl[band] += mag*freq;
				wbandf_l[band] += mag;

				mag = m[i];
				mag = mag * wRight * gainRight;
				mr[band] += mag * polarity;
				wbandm_r[band] += wRight; 
				fr[band] += mag*freq;
				wbandf_r[band] += mag;
			);
			i+=1;
		);

		j+=1;
	);

	// rebalance everything
	i=0; loop(HALF_FFTSIZE,
		wbandm_l[i]>0 ? ml[i] = abs(ml[i])/wbandm_l[i] : ml[i]=0;
		wbandf_l[i]>0 ? fl[i] = fl[i]/wbandf_l[i]      : fl[i]=0;
		wbandm_r[i]>0 ? mr[i] = abs(mr[i])/wbandm_r[i] : mr[i]=0;
		wbandf_r[i]>0 ? fr[i] = fr[i]/wbandf_r[i]      : fr[i]=0;

		i+=1;
	);

	vocoderEnabled ? (

		// vocoder
		a = lastInputSnap;
		// vfa = vocoderBalanceA/(vocoderBalanceA+vocoderBalanceB);
		// vfb = vocoderBalanceB/(vocoderBalanceA+vocoderBalanceB);
		vfa = vocoderBalanceA;
		vfb = vocoderBalanceB;
		ma = snapMPtr(a);
		fa = snapFPtr(a);
		i=0; 
		loop(HALF_FFTSIZE,
			pivot = enhPivot[i];

			ga = log(ma[i]/pivot);
			gb = log(ml[i]/pivot);
			gc = ga*vfa+gb*vfb;
			gc<0 ? gc=gc*enhAlphaDown : gc*enhAlphaUp;
			//gc<1 ? gc=pow(gc, enhAlphaDown) : gc=pow(gc, enhAlphaUp) ;
			ml[i] = pivot*exp(gc);

			gb = log(mr[i]/pivot);
			gc = ga*vfa+gb*vfb;
			gc<0 ? gc=gc*enhAlphaDown : gc*enhAlphaUp;
			//gc<1 ? gc=pow(gc, enhAlphaDown) : gc=pow(gc, enhAlphaUp) ;
			mr[i] = pivot*exp(gc);


			
			// frequencies are linearly interpolated
			fl[i] = (fa[i]*vfa + fl[i]*vfb)/(vfa+vfb);
			fr[i] = (fa[i]*vfa + fr[i]*vfb)/(vfa+vfb);
			
			i+=1;
		);

	):(
		// alpha enhancement
		enhGreater = enhSmaller = 0;
		
		i=0; loop(HALF_FFTSIZE,
			pivot = enhPivot[i];
			ml[i] > pivot ? (
				ml[i] *= pow(ml[i]/pivot, enhAlphaUp-1);
				enhGreater += 1;
			) : (
				ml[i] *= pow(ml[i]/pivot, enhAlphaDown-1);
				enhSmaller+=1;
			);

			mr[i] > pivot ? (
				mr[i] *= pow(mr[i]/pivot, enhAlphaUp-1);
				enhGreater+=1;
			) : (
				mr[i] *= pow(mr[i]/pivot, enhAlphaDown-1);
				enhSmaller+=1;
			);

			i+=1;
		);
	);


	memcpy(drawSpecBufLeft,  ml, HALF_FFTSIZE);
	memcpy(drawSpecBufRight, mr, HALF_FFTSIZE);
);


function getCurrentPoint() local(i dx dy d mind cur alpha enabled) (
	status != STATUS_RECORD_PREVIEW  ? (
		mind=8;
		curSelected = curHoveredPoint = -1;
		
		i = 0;
		loop(npoints, 
			dx = (mouse_norm_x-points[i][SNAP_X]) * dragArea.width;
			dy = (mouse_norm_y-points[i][SNAP_Y]) * dragArea.height;
			d = sqrt(dx*dx + dy*dy);
			d<mind ? (
				mind = d;
				curSelected = curHoveredPoint = i;
			);
			i+=1;
		);
	);
	curSelected;
);

function incPointLfoPh() local (i p) (
	i=0;
	loop(npoints,
		p = points[i];
		p[SNAP_LFO_PH] += pow(p[SNAP_MOVEMENT_V], 4)*.01;
		p[SNAP_LFO_PH] > $pi ? p[SNAP_LFO_PH]-=2*$pi;
		i+=1
	);
);

function drawCircles() local(i j snap x y w n alpha)(
	NCIRCLES=25;
	i=0;

	loop(npoints,
		snap=points[i];
		x = snap[SNAP_X];
		y = snap[SNAP_Y];
		wl = snap[SNAP_LEFT_WEIGHT]/totalWeightLeft;
		wr = snap[SNAP_RIGHT_WEIGHT]/totalWeightRight;
		w = (wl+wr)/2;
		n = floor(w*NCIRCLES+.5);
		n = min(n, NCIRCLES);

		j=1;
		x = normToPhisicX(x);
		y = normToPhisicY(y);

		loop(n,
			alpha = wl*(n-j)/n;
			ui_color(128,128,256, alpha);
			gfx_arc(x-1, y, j*15, -$pi, 0, 1);
			
			alpha = wr*(n-j)/n;
			ui_color(255,128,128, alpha);
			gfx_arc(x+1, y, j*15, $pi, 0, 1);
			
			j += 1;
		);

		i+=1;
	);
);

function drawAutoMovingPath() local(p x y inc) (
	ui_color(255, 255, 255, .33);

	p=0;
	inc = 2*$pi/floor(5+autoMoveRadius*300);
	while(
		dragged.obj == DRAGGED_OBJ_LISTENER ? (
			x = normToPhisicX(listener.center.x + sin(p)*.5*autoMoveRadius);
			y = normToPhisicY(listener.center.y + cos(p)*.5*autoMoveRadius);

			gfx_line(x,y,x,y); 
		);
		p+= inc;
		p<2*$pi;
	);
);

function drawSnaps() local(i j x y k cx cy px py snap enabled cw) (
	getCurrentPoint();

	//ui_colorfont(2,"Arial", 14, "b");
	i=0;
	loop(npoints, 
		snap = points[i];
		cx = snap[SNAP_X];
		cy = snap[SNAP_Y];
		enabled = (snap[SNAP_FLAGS] & IS_MUTE_FLAG) == 0;
		enabled = enabled && (soloPoint<0 || soloPoint==i);

		cw = (snap[SNAP_LEFT_WEIGHT]/totalWeightLeft+snap[SNAP_RIGHT_WEIGHT]/totalWeightRight)*.5;
		cw = pow(cw,.5);
		cw = min(1, cw);
		cw = max(.25, cw);

		enabled ? ui_color(255,255,0,1) : ui_color(128,128,128,.7);
		x = normToPhisicX(cx);
		y = normToPhisicY(cy);
		gfx_a = cw;
		gfx_circle(x,y,11,0, 1); 

		// red ring around cur selected
		i==curSelected ? (
			ui_color(255,0,0,1);
			j=0;
			loop(10, 
				gfx_circle(x, y, 9+j/3, 0, 1); 
				j += 1;
			);
		);
		// blue ring around cur edit
		isEditMode() && i==curEditingPoint ? (
			ui_color(0,0,255,1);
			j=0;
			loop(10, 
				gfx_circle(x, y, 9+j/3, 0, 1); 
				j += 1;
			);
		);

		

		enabled ? ui_color(255,255,0,1) : ui_color(128,128,128,.7);
		mystr = pointLabel(i);

		gfx_measurestr(mystr, str_w, str_h);
		gfx_x = x - str_w/2+2;
		gfx_y = y - str_h/2+1;
		gfx_a = cw;
		gfx_drawstr(mystr);

		// satellite
		!isRecordMode() && snap[SNAP_MOVEMENT_R]>0 ?(
			px = normToPhisicX(getPointX(snap));
			py = normToPhisicY(getPointY(snap));
			//cw = pow(cw,3);
			gfx_mode=0;

			ui_color(0,128,0);
			gfx_a = cw;
			gfx_line(px,py,x,y);

			ui_color(255,255,255);
			gfx_a = cw;
			gfx_circle(px, py, 1.5, 1,0); 

			gfx_a = 1;
		);

		i += 1;
	);

	!isRecordMode() ? (
		// green cross
		ui_color(0, 255, 0, 1);
		x = normToPhisicX(listener.center.x);
		y = normToPhisicY(listener.center.y);
		gfx_line(x-7, y-7, x+7, y+7);
		gfx_line(x+7, y-7, x-7, y+7);
		
		ui_color(128, 128, 255, 1);
		x = normToPhisicX(xPlayLeft);
		y = normToPhisicY(yPlayLeft);
		//gfx_line(x-5, y-5, x+5, y+5);
		//gfx_line(x-5, y+5, x+5, y-5);
		gfx_circle(x, y, 4, 0, 1);

		ui_color(255, 128, 128, 1);
		x = normToPhisicX(xPlayRight);
		y = normToPhisicY(yPlayRight);
		//gfx_line(x-5, y-5, x+5, y+5);
		//gfx_line(x-5, y+5, x+5, y-5);
		gfx_circle(x, y, 4, 0, 1);

		enableShowCircles ? drawCircles();

		drawAutoMovingPath();
	);
);

function duplicateSnap(index) local(src ptr) (
	
	src = points[index];
	ptr = points[npoints];
	initPVSnap(ptr);
	
	memcpy(ptr, src, pvSnapSize());
	ptr[SNAP_X] = phisicToNormX(normToPhisicX(src[SNAP_X])+25);
	
	sprintf(STR_POINT_NAMES+npoints, "%s'", STR_POINT_NAMES+index);
	
	ptr[SNAP_GAIN] = src[SNAP_GAIN];
	ptr[SNAP_FLAGS] = src[SNAP_FLAGS]; 
	ptr[SNAP_TRANSP] = src[SNAP_TRANSP];
	ptr[SNAP_LO_CUT] = src[SNAP_LO_CUT];
	ptr[SNAP_HI_CUT] = src[SNAP_HI_CUT];
	ptr[SNAP_LFO_PH] = src[SNAP_LFO_PH];
	ptr[SNAP_MOVEMENT_R] = src[SNAP_MOVEMENT_R];
	ptr[SNAP_MOVEMENT_V] = src[SNAP_MOVEMENT_V];
	ptr[SNAP_BOTTOM_CUT] = src[SNAP_BOTTOM_CUT];
	ptr[SNAP_P_SHIFT] = src[SNAP_P_SHIFT];

	computePoint(npoints);
	npoints +=1;
	setDataChanged();
	npoints-1;
);


function deleteSnap(index) local() (
	last = npoints-1;
	n = last - index;
	i = index;
	loop(n,
		points[i] = points[i+1];
		strcpy(STR_POINT_NAMES+i, STR_POINT_NAMES+i+1);
		i +=1;
	);
	npoints = npoints-1;

	setDataChanged();
);

function lin_drawFFT(ptr, left, top, width, height, hswap) local(x y xinc i base buf) (
	buf = drawFFTBuf;

	i=0;
	base = top+height;
	x = hswap ? left+width-1 : left;
	xinc = hswap ? -width*2/FFTSIZE : width*2/FFTSIZE;

	i=0;
	loop(HALF_FFTSIZE, 
		y = toDb(ptr[i]); 
		y = min(max(fftShowBase, y), fftShowTop);
		y = (y-fftShowBase)/(fftShowTop-fftShowBase);
		y = y*height;
		gfx_line(x, base, x, base-y);
		x += xinc;
		i += 1;
	);

	//show pivot
	!isRecordMode() ? (
		ui_color(255,0,0,1);
		x = hswap ? left+width-1 : left;
		i=1;
		loop(HALF_FFTSIZE, 
			y = toDb(enhPivot[i]);
			y = min(max(fftShowBase, y), fftShowTop);
			y = (y-fftShowBase)/(fftShowTop-fftShowBase);
			y = y*height;
			i==1?(
				gfx_x=x;
				gfx_y=base-y;
			):(
				gfx_lineto(x, base-y);
			);
			x += xinc;
			i += 1;
		);
	);


);


function drawDbScale(left, top, width, height) local(y ydb base) (
	gfx_setfont(1,"verdana", 10);

	base = top+height;
	ydb = 6*ceil(fftShowBase/6);
	while(
		y = base-(ydb-fftShowBase)/(fftShowTop-fftShowBase)*height;
		ui_color(128,255,128,.15);
		gfx_line(left, y, left+width-34, y);

		gfx_x = left+width-30; 
		gfx_y = y-6; 
		ui_color(128,255,128,1);
		gfx_printf("%d dB", ydb); 

		ydb+=6;
		ydb<fftShowTop;
	);
	gfx_setfont(0);
);


function exp_drawFFT(ptr, left, top, width, height) 
  local(x y i base buf f k kmin kmax lastx curY) (


//	  gfx_set(255,255,255);
//	  gfx_line(left, top, left+width, top+height);
//	  gfx_line(left+width, top, left, top+height);

	buf = drawFFTBuf;
	base = top+height;
	kmax=fToKey(srate/2);
	kmin=fToKey((srate/2)/HALF_FFTSIZE);

	lastx=left;
	memset(drawFftBuffer, -1, drawFftBufferSize);

	i=1;
	loop(HALF_FFTSIZE-1, 
		f = i*(srate/2)/HALF_FFTSIZE;
		k = fToKey(f);
		x = (k-kmin)/(kmax-kmin);
		x = max(0, min(x,1));
		x = floor(left + x*width);

		y = ptr[i];
		drawFftBuffer[x] = max(drawFftBuffer[x], y); 


		i+=1;
	);

	i = drawFftBufferSize-1;
	curY=0;
	while(
		drawFftBuffer[i] >= 0 
			? curY=drawFftBuffer[i] 
			: drawFftBuffer[i]=curY;
		i -=1;
		i>=0;
	);

	x=left;
	loop(width, 
		y = toDb(drawFftBuffer[x]);

		y = 1 - y/fftShowBase;
		y = max(0, min(y,1));
		y *= height;
		gfx_line(x, base, x, base-y);
		x += 1;
	);

);

function drawKbd(left, top, width, height) 
  local(k kleft kright kmax kmin dy h) (

	kmax=fToKey(srate/2);
	kmin=fToKey((srate/2)/HALF_FFTSIZE);
	kshowmin = kmin+24;
	kshowmax =kmax-12;
	kwidth = width/(kmax-kmin);

	gfx_set(255,255,255,1);
	gfx_rect(left,top,width,height);

	k = floor(kmin);
	while(
		kleft = left+((k-kmin) - .5)*kwidth;
		kright = left+((k-kmin) + .5)*kwidth;
		k12 = k % 12;
		(k12==1 || k12==3 || k12 == 6 || k12 == 8 || k12 == 10) ?	(
//			gfx_set(255,255,255,1);
//			gfx_rect(kleft,top,kright-kleft,height);
			gfx_set(0,0,0,1);
			gfx_rect(kleft,top,kright-kleft,height*.65+1);
		 ) : (

			//gfx_set(255,255,255,1);
			k == 60? (
				gfx_set(255,0,0,1);
				gfx_rect(kleft,top,kright-kleft+1,height);
			);
		);
		k += 1;
		k<kmax; 
	);


);


function restartPh() (
	pvin.fftobj.incount = pvin.fftobj.inputLatency;
    pvin.fftobj.count = 0;
    pvin.fftobj.overcount = 0;

    pvout1.fftobj.overcount = 0;
    pvout2.fftobj.overcount = 0;


	memset(pvout1.phacc, 0, HALF_FFTSIZE);
	memset(pvout2.phacc, 0, HALF_FFTSIZE);
	memset(pvin.prev, 0, HALF_FFTSIZE);
);


